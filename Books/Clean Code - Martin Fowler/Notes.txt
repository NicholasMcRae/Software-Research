Functions
- The first rule of functions is that they should be small
- They should do one thing, do it well
- keep the interior of each function at a single level of abstraction
- Single Responsibility Principle - more than one reason for it to change
- Switch Statements
	- we can't always avoid switch statements
	- can make sure switch statements are buried in a low-level class and not repeated
	- do this with polymorphism
		- Consider a function that might depend on type of employee
		- Several problems
			- large
			- employee is added, it will grow
			- does more than one thing
			- violates single responsibility principle - more than one reason for it to change
			- worst problem is that there are an unlimited number of other functions that will have the same structure
				- all will have the same structure
		- solution: bury the switch statement in the basement of an abstract factory and never let anyone see it
		- the factory will use the switch statement to create appropriate instances of the derivatives of Employee
		- various functions, such as calculatePay, isPayDay, and deliverPay will be dispatched polymorphically through the Employee interface
		- so you're creating an employee factory method which returns instances of subclasses of employee, which are implementations of specific employee types
	- general rule for switch statements is that they can be tolerated if they appear only once, are used to create polymorphic objects, and are hidden behind an inheritance
- Function arguments
	- the ideal number of arguments for a function is zero, next is one, followedby two
	- three should be avoided where possible
	- more than three requires very special justification and then shouldn't be used anyway
		- mainly because it makes testing harder
	- flag arguments
		- ugly
		- passing a boolean in is a truly terrible practice
	- Triad functions
		- when a function seems to need more than two or three arguments it is likely that some of those arguments ought to be wrapped into a class of their own
		- when groups of variables are passed together the way x and y are in the xample they are likely part of a concept that deserves a name of its own
- Have no side effects
	- minimize mutability
- Output arguments
	- In general output arguments should be avoided
	- If your function must change the state of something, have it change the state of its owning object
- Command Query Separation
	- Functions should either do something or answer something, but not both
	- Function should change the state of an object or it should return some information about that object
	- Doing both often leads to confusion
- Prefer exceptions to returning error codes

Comments
- the proper use of comments is to compensate for our failure to express ourself in code
- tendency should be to try to express ourselves in code rather than comments
- comments create point of maintainability
- a comment may be used to amplify the importance of something that may otherwise seem inconsequential
- if you have to write a comment, write a good comment, don't mumble

Formatting
- Files should be as small as possible
- Concepts that are close to each other should be kept close to each other
- variables should be declared as close to their usage as possible
- instance variables should be declared at the top of the class
- if one function calls another they should be vertically close, and the caller should be above the callee - gives the program a natural flow
- conceptual affinity - certain bits of code want to be near other bits, they have a certain conceptual affinity
- we want function call dependencies to point in the downward direction. Most important concepts to come first
- lines should be short
- we want horizontal white space to associate things that are strongly related, and  disassociate things that are more weakly related

Objects and Data Structures
- hiding implementation is not just a matter of putting a layer of functions between the variables, it's about abstraction. A class does not simple push its variables out through getters and setters. Rather it exposes interfaces that allow its users to manipulate the essence of the data, without having to know its implementation
- we don't want to expose the details of our data
- rather we want to express our data in abstract terms
- not just done with getters and setters, serious thought needs to be put into the best way to represent the data that an object contains
- Data/Object Anti-Symmetry
	- objects hide their data behind abstractions and expose functions that operate on that data
	- data structures expose their data and have no meaningful functions
	- Consider what would happen if a perimeter function were added to Geometry
	- The shape classes would be unaffected
	- Any other classes that depended on the shapes would also be unaffected
	- on the other hand, if I add a new shape, I must change all the functions in Geometry to deal with it
	- Procedural code (code using data structures) makes it easy to add new functions without changing the existing data structures. OO code, on the other hand, makes it easy to add new classes without changing existing functions
	- In any complex system there are going to be times when we want to add new data types rather than new functions, for these cases objects and OO are most appropriate
	- On the other hand, there will also be times when we'll want to add new functions as opposed to data types. In that case procedural code and data structures will be more appropriate
	- Mature programmers know that the idea that everything is an object is a myth. Sometimes you really do want simple data structures with procedures operating on them
- The Law of Demeter
	- a module should not know about the innards of the objects it manipulates
	- As we saw in last section - objects hide their data and expose operations
	- This means that an object should not expose its internal structure through accessors because to do so is to expose, rather than to hide, its internal structure
	- More precisely, the Law of Demeter says that a method f of a class C should only call the methods of these:
	- C
	- an object created by f
	- an object passed as an argument to f
	- an object held in an instance variable of C
	- the method should not invoke methods on objects that are returned by any of the allowed functions
	- example
	- Where the example is a violation of demeter depends on whether or not ctxt, options, and scratchdir are objects or data structures
	- If they are objects then their internal structure should be hidden rather than exposed
	- on the other hand, if they are just data structures with no behavior, then they naturally expose their internal structure and so demeter does not apply
- Hybrids
	- This confusion sometimes leads to unfortunate hybrid structures that are half object and half data structure
	- They have functions that do significant things, and they also have either public variables or public accessors and mutators that, for all intents and purposes, make the private variables public
	- Avoid creating them
	- They are indicative of a muddled design whose authors are unusure of, or worse, ignorant of, whether they need protection from functions or types
- Hiding Structure
	-If ctxt is an object, we should be telling it to do something, we should not be asking it about its internals
- Data Transfer Objects
	- The quintessential data structure is a class with public variables and no functions
	-  This is sometimes called a data transfer object
	- very useful structures, especially when communicating with databases or parsing messages
	- beans with getters setters often actually provide no benefit
	
Error Handling
- Error handling is important, but if it obscures logic, it's wrong
- Use exceptions rather than return codes
- Write your try-catch-finally statement first
	- don't tangle concerns
	- the algorithm fromt he function and the error handling can be separated
- Use unchecked exceptions
	- we now know it's clear that checked exceptions aren't necessary for the production of robust software
- Provide context with exceptions
	- each exception that you throw hsould provid enough context to determine the source and location of an error
	- mention the operation that  failed and the type of failure
- Don't Return Null
	- with function calls don't return null
- Don't pass null
- Conclusion
	- We can write robust, clean code if we see error handling as a separate concern, something that is viewable independently of our main logic
	- To the degree that we are able to do that, we can reason about it independently and we can make great strides in the maintainability of our code
	
Boundaries
	- In this chapter we look at practices and techniques to keep the boundaries of our software clean
	- there is a tension between the provider of an interface and the user of an interface
	- providers of third party packages and frameworks strive for broad applicability so they can work in many environments and appeal to a wide audience
	- users on the other hand want an interface that is focused on their particular needs
	- e.g. passing around a map
	- Map has a very broad interface with is useful, but can be a liability
	- our application might build up a map and pass it around
	- our intention might be that none of the recipients of our Map delete anything in the map, but the map has a clear method which could be used
	- or maybe our design convention is that only particular type sof objects can be stored in the map, but maps do not reliably constrain the types of objects placed within them
	- passing an instance of map<sensor> liberally around the system means that there willbe a lot of places to fix if the interface to Map ever changes
	- you may think such a change to be unlikely but remember that it changed when generics support was added in java 5
	- a cleaner way to use map
		- the interface at the bo8undary (map) is hidden
		- it is able to evolve with very little impact on the rest of the application
		- the use of generics is no longer a big issue becuase the casting and type management is handled inside the sensors class
		- the sensors class can enforce design and business rules
	- not suggesting that every use of map be encapsulated in this form, rather are advising not to pass maps, or any other interface at a boundary, around your system
	- if you use a bo8undary interface like map keep it inside the class, or close family of classes
	- **avoid returning it from, or accepting it as an argument to public APIs
	- Exploring and learning boundaries
		-it's not our job to test the third party code, but it may be in our best interest to write tests for the third-part code we use
		- instead of experimenting and trying out the new stuff in our production code we could write some tests to explore our understanding of the third-party code
		- Jim NEwkirk calls such tests learning tests
	- Clean boundaries
		- good software designs accomodate change without huge investments and rework
		- Code at the boundaries needs clear separation and tests that define expectations
		- We should avoid letting too much of oru code know about the third party particulars
		- it's better to depend on something you control than on something you don't control, lest it end up controlling you
		- We manage third-party boundaries by having very few places in the code that refer to them
		- we may wrap them as we did with map or we may use an adapter to convert from our perfect interface to the provided interface
		- either way our ocde speaks to us better
		
Unit Tests
	- The three laws of TDD
		- You may not write production code until you have written a failing unit test
		- You may not write more of a unit test than is sufficient to fail, and not compiling is failing
		- you may not write more production code than is sufficient to pass the currently failing test
	- Want to maintain your tests as well as your production code
	- if you have maintained unit tests you don't have to worry about writing production code
	- readability makes a clean test
	
Classes
	- the first rule of classes is that they should be small
	- a class should only have one responsibility
	- cohesion
		- classes should have a small number of instance variables
		- each of the methods of a class should manipulate one or more of those variables
		- in general, the more variables a method manipulates the more cohesive that method is to its class
		- a class in which each variable is used by each method is maximally cohesive
		- in general it is neither advisable nor possible to create such maximally cohesive classes
		- when cohesion is high, it means that the methods and variables of the class are co-dependent and hang together as a logical whole
	- maintaining cohesion results in many small classes
	- in a clean system we organize our classes so as to reduce the risk of change
		- when we want to change a class we have to open it up which introduces risk
		- we'll need to re-test the class
		
Systems
	- cities work because they have teams of people who manage particular parts of the city - water systems, power systems, traffic, law enforcement, building codes and so forth
	- cities also workbecause they have evolved appropriate levels of abstraction and modularity that make it possible for individuals and the components they manage to work effectively, even without understanding the big picture
	- although software teams are often organized like that too, the systems they work on often don't have the same separation of concerns and levels of abstraction
	- Clean code helps us achieve this at the lower levels of abstraction. In this chapter let us consider how to stay clean at higher levels of abstraction, the system level
	- Separate constructing a system from using it
		- software systems should separate the startup process, when the application objects are constructed, and the dependencies are wired together, from the runtime logic that takes over after startup
		- the startup process is a concern that any application must address
		-it is the first concern we will examine
		- separation of concerns is one of the oldest and most important design techniques in our craft
		- one occurrence of lazy initialization isn't a serious problem, however there are normally many instances of little setup idioms like this in applications. Hence, the global setup strategy is scattered across the application, with little modularity and often significant duplication
		- if we are diligent about building well-formed and robust systems, we should never let little, convenient idioms lead to modularity breakdown. The startup process of object construction and wiring is no exception
		- We should modularize this process separately from the normal runtime logic and we should make sure that have have a global, consistent strategy for resolving our major dependencies
	- Separation of Main
		- one way to separate construction from use is to move all aspectsof construction to main, or modules called by main
		- design the rest of the system assuming that all object have been constructed and wired up approrpiately
		- the flow of controlis easy to follow, the main function builds the objects necessary for the system then passes them to the application, which uses them
		- means that the application has no knowledge of main or of the construction process, it simply expect that everything has been built properly
	- Factories
		- Sometimes we need to make the application responsible for when an object gets created
		- in this case we can use the abstract factory pattern to give the application control of when to build the (e.g.) lineitems
		- but keep the details of that construction separate from the application code
	- Dependency Injection
		- a powerful mechanism for separating construction from use is dependency injection
		- inversionof control moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the single responsibility principle
		- in the context of dependency management, an object should not take responsibility for instantiating dependencies itself
		- instead it should pass this responsibility to another mechanism, thereby inverting the control
		- the authoritative mechanism will usually be either the main routine or a special purpose container
	- Scaling Up
		- It is a myth that we can get systems 'right the first time'
		- Instead we should implement only today's stories, then refactor and expand the system to implement new stories tomorrow
		- this is the essence of iterative and incremental agility
		- But what about at the system level? Doesn't the system architecture require preplanning? Certainly, it can't grow incrementally from simple to complex,c an it?
		- 'Software systems are unique compared to physical systems. Their architectures can grow incrementally if wemaintain the proper separation of concerns'
		- ..loosely coupled components
		- separating concerns is our main concern in architecture
	- Various tools in Java for separating concerns
	- Optimize Decision Making
		- modularity and separation of concerns make decentralized management and decision making possible
		- we all know it is best to give responsibilities to the most qualified persons
		- we often forget that it is also best to postpone decisions until the last possible moment
		- this isn't lazy or irresponsible, it lets us make informed choices with the best possible information
		- a premature decision is a decision made with suboptimal knowledge
		- we will have that much less customer feedback, mental reflection on the project, and experience with our implementation choices if we decide too soon
		- the agility provided by a POJO system with modularized concerns allows us to make optimal, just-in-time decisions, based on the most recent knowledge. The complexity of these decisions is also reduced
	- Use standards wisely
		- Standards make it easier to reuse ideas and components, recruit people with relevant experience, encapsulate good ideas, and wire components together. However, the process of creating standards can sometimes take too long for industry to wait, and some standards lose touch with the real needs of the adopters they are inteded to serve
	- Systems need domain specific languages
		- a good dsl minimizes thecommunication gapbetween a domain concept and the code that implements it, just as agile practices optimize the communcations within a team and with the project's stakeholders
	- whether you are designing systems or individual modules, never forget to use the simplest thing that can possibly work
		- 