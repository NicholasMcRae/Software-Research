- Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code, yet improves it's internal structure
- Disciplined way to clean up code that minimizes the chances of introducing bugs
- Improving the design after it has been written
	- In current understanding we believe that we design and then we code
	- The code slowly sinks from engineering to hacking
- Refactoring is the opposite of this practice
	- Take a bad design, chaos even, and re-work it into well designed code
- You find design occurs continuously during development
- You learn from building the system how to improve the design
- You will learn to refactor in such a way that you don't introduce bugs into the code but instead methodically improve the structure
- For all of this book I use examples in Java
- Two of the leading proponents of refactoring are Ward Cunningham and Kent Beck

Chapter 1
- The first step
	- Need to build a solid set of tests for that section of code
	- Tests are essential because we're still human and still make mistakes
	- Thus, need solid tests
	- It is vital to make tests self-checking, if you don't you end up spending time hand checking some numbers
		- Slows you down
	- Relying on tests to tell me whether I introduce a bug
	- It is essential for refactoring that you have good tests
	- It's worth spending the time to build the tests, because the tests give you the security you need to change the program later
	- This is so important it's Chapter 4

- Decomposing and Redistributing the Statement Method
	- The first target of attention is the overly long statement method
	- Looking to decompose the method into smaller pieces
	- Smaller pieces of code tend to make things more manageable
	- They are easier to work with and move around
	- Aim is to make it easier to write an HTML statement method with much less duplication of code
	- Switch statement looks like a good chunk to extract into its own method
	- Need to do it safely
	- Need to look in the fragment for any variables that are local in scope to the method we are looking at, local variables and parameters
	- Has two: each is not modified by the code but thisAmount is modified
	- Any non-modified variable I can pass in as a parameter
	- Modified variables need more care
		- If there is only one, I can return it
	- Whenever I make a change like this, I compile and test
	- Smalltalk, the refactoring browser. With this tool refactoring is very simple, just highlight the code, pick extract method, type in a method name, and it's done
	- Now that I've broken the original method down into chunks I can work on them separately
	- I don't like some of the variable names in amountFor, and this is a good place to change them
	- Is renaming worth the effort?
	- Absolutely, good code should communicate what it is doing clearly, and variable names are a key to clear code
	- Code that communicates its purpose is very important
	
	- Moving the Amount Calculation
	- Uses information from rental, but does not use information from Customer
	- This immediately raises my suspicions that the method is on the wrong object
	- In most cases, a method should be ont he object whose data it uses
	- thus the method should be moved to the rental
	- In this case, fitting into its new home means removing the parameter, I also renamed the method as I did the move
	- Can now compile and test to see whether I've broken anything
	- The next step is to find every reference to the old method and adjust the reference to use the new method as follows
	- In this case the step is easy because we just created the method and it is in only one place
	- Now we have to remove the old method
		- Sometimes I leave the old method to delegate to the new method, this is useful if it is a public method and I don't want to change the interface of the other class
	- Now I notice that the variable thisAmount is redundant, so I can replace it with the function call of getcharge()
	- I like to get rid of temporary variables such as this as much as possible, often a problem in that they cause a lot of parameters to be passed around when they don't have to be
	- You can easily lose track of what they are there for
	- They are particularly insidious in long method
	- There is a performance price to pay, the charge is now calculated twice, but it is easy to optimize that in the rental class
	
	- Extracting Frequent Renter Points
	- Seems reasonable to put the responsibility on the rental
	- First we need to use Extract Method on the frequent retner points part of the code
	- Each is used and can be passed in as a parameter, the other temp used is frequentRenterPoints
		- Does have a value beforehand
		- The body of the extracted method doesn't read the value, so we don't need to pass it in as a parameter
	- With refactoring, small steps are the best, that way less tends to go wrong
	
	- Removing Temps
	- Temporary variables can be a problem
	- The other concern with this refactoring lies in performance-
	- The old code executed the while loop once
	- A while loop that takes a long time might impair performance
	- Many programmers would not do this refactoring simply for this reason
	- Note words if and might
	- Until I profile I cannot tell how much time is needed for the loop to calculate or whether the loop is called often enough for it to affect overall performance
	- Don't worry about this while refactoring, when you optimize you will have to worry about it
	- But you will then be in a much better position to do something about it
	- Now I can write the htmlSTatement
	- If the calculation rules change I have only one place in the code to go to
	- Any other kind of statement will be really quick and easy to prepare
	
	- Replacing the conditional logic on price code with polymorphism
	- It is a bad idea to do a switch based on an attribute of another object
	- If you must use a switch statement, it should be on your own data, not on someone else's
	- This implies that getCharge should move onto movie
	
	- Inheritance
	- We have several types of movie that have diffferent ways of answering the same question
	- Sounds like a job for subclasses
	- Now completed the second major refactoring, it is going to be much easier to change the classification structure of movies, and to alter the rules for charging 
	
	- The most important lesson from this example is the rhythm of refactoring: test, small change, test, small change, test, small change
	
Chapter 2 - Principles in Refactoring
	- The previous example should give you a feel for what refactoring is all about
	- Now it's time to step back and look at the key principles of refactoring and at some of the issues you need to think about when refactoring
	- Refactoring has two definitions depending on context
	- As a noun or a verb
	- Refactoring goes further than just clean up because it provides a technique for cleaning up code in a more efficient and controlled manner
	- Know which refactorings to use
	- Know how to minimize bugs, and test at every possible opportunity
	- The purpose of refactoring is to make the software easier to understand and modify
	- Only alters the internal structure
	- Refactoring does not change the observable behavior of the software
	- Refactoring improves the design of software
	- Without refactoring, the design of the program will decay
	- Code can lose it's structure
	- Refactoring makes software easier to understand
	- Refactoring helps you find bugs
	- Refactoring helps you program faster
	- The third time, you refactor (once you find yourself duplicating code often)
	- The most common time to refactor is when I want to add a new feature to some software
		- When I want to understand the code
		- Or if the design doesn't help me add a feature easily
	- Refactor when you need to fix a bug
	- Refactor as you do a code review
	- The idea of active code review is taken to its limit with Extreme Programming practice of Pair Programming
	- All serious development is done with two developers at one machine
	- Want to structure in a code that makes changes later easier
	- Poor structure makes software hard to modify
	- What do I tell a manager? If they like quality it's easy, if not sometimes don't tell
	- Problems with refactoring
		- Databases, applications are tightly coupled, difficult to change
		- Changing interfaces
	- When shouldn't you refactor?
		- when you should rewrite from scratch instead, the existing code is such a mess that although you could refactor, it would be easier to start from the beginning
		- A re-write is needed when the current code just does not work
		- Code has to work mostly correctly before you refactor
		- Also when you are close to a deadline
			- It's important to manage debt
	
	- Refactoring and Design 
		- Many consider design to be the key piece and programming just mechanics
		- One argument is that refactoring can be an alternative to upfront design
		- You don't do any design at all, you just code the first approach that comes, get it working, and then refactor it into shape
		- This approach can work, XP Kent Beck advocate this approach
		- Even the extreme programmers do some design first, want a plausible first solution
		- If you don't refactor, there is a lot of pressure in getting that upfront design right
		- The sense is that any changes to the design later are going to be expensive
		- With refactoring all you want is a reasonable solution, with refactoring not a problem because it is no longer expensive to make the change
		- Greater movement toward simplicity of design
		- Flexible solutions are more complex than simple ones, they cost
		- The resulting software is more difficult to maintain in general
		- To gain flexibility you are forced to put in a lot more flexibility than you actually need
		- With refactoring you still think about potential changes, still consider flexible solutions
		- But instead of implementing these flexible solutions, you ask: how difficult is it going to be to refactor a simple solution into the flexible solution?
		- if it's pretty easy then you just implement the simple solution
		- Once you have a broad sense of things that refactor easily, you don't even think of the flexible solutions
		- You have the confidence to refactor if the time comes
		
		- Refactoring and Performance
		
Chapter 3: Bad Smells in Code
	- Deciding when to start and when to stop is just as important as knowing how to operate the mechanics of refactoring
	- Duplicated code
		- if you see same code structure in more than one place, you can be sure that your program will be better if youf ind a way to unify them
		- when you have the same expression in two sibling subclasses
		- if you have duplicated code in two unrelated classes, consider using extract class
	- Long Method
		- the object programs that live best and longest are those with short methods
		- little methods are valuable
		- the longer a procedure is, the more difficult it is to understand
		- should be much more aggressive about decomposing methods
			- whenever we feel the need to comment something, we write a method instead
			- can do on a group of lines or even a single line of code
		- if you have a method with lots of parameters and temporary variables, these elements get in the way of extracting methods
		- Comments often signal this kind of semantic didstance
	- Large Class
		- when a class is trying to do too much
		- a class with too much code is prime breeding ground for duplicated code, chaos, and death
		- the simplest solution is to eliminate redundancy in the class itself
	- Long Parameter List
	- Divergent Change
		- Occurs when one class is commonly changed in different ways for different reasons
	- Shotgun Surgery
		- When every time you make a kind of change,y ou have to make a lot of little changes to a lot ot different classes
	- Feature Envy
		- points of objects is that they are a technique to package data with the processes used on that data
		- a classic smell is a method that seems more interested in a class other than the one it is actually in
	- Data Clumps
		- Bunches of data that hang around together really ought to be made into their own object
		- A good test is to consider deleting one of the data values, if you did this, would the others make any sense?
	- Primitive Obsession
		- People new to objects are usually reluctant to use small objects for small tasks
		- You can move out of the cave into the centrally heated world of objects by using replace data value with object
	- Switch Statements
		- Often you find the same switch statements scattered about a program in different places
		- If you add a new clause to the switch, you ahve to find all these switch statements and change them
		- Most times you swee a switch statement you should consider polymorphism
	- Parallel Inheritance Hierarchies
		- Every time you make a subclass of one class you also have to make a subclass of another
	- Lazy Class
		- If you have subclasses that aren't doing enough, try to use collapse hierarchy. Nearly useless components should be subjected to inline class
	- Speculative Generality
		- Handling cases that don't exist
		- The result is often harder to understand and maintain
		- The machinery just gets in the way, so get rid of it
	- Temporary Field
		- Instance variable is set only in certain circumstances
	- Message Chains
		- Message chains, client is coupled to the structure of the navigation
		- Any change to the intermediate relationships causes the client to have to change
	- Middle Man
		- You look at a class's interface and find half the methods are delegating to this other class
	- Inappropriate intimacy
		- Classes become far too intimate and spend too much time delving in each other's private parts
	- Alternative Classes with Different Interfaces
	- Incomplete Library Class
	- Data Class
		- Such classes are dumb data holders and are almost certainly being manipulated in far too much detail by other classes
	- Refused Bequest
		- 
		
 Chapter 4: Building Tests
	- If you want to refactor, the essential precondition is having solid tests
	- Make sure all tests are fully automatic and that they check their own results
	- A suite of tests is a powerful bug detector that decapitates the time it takes to find bugs
	- JUnit Testing Framework
	- Unit vs Functional Tests
	- When you get a bug report, start by writing a unit test that exposes the bug
	- Adding More Tests
		- Look at all the things the class should do and test each one of them for any conditions that might cause the class to fail
		- Testing should be risk driven, you are trying to find bugs now or in the future
		- You don't test accessors that just read and write a field